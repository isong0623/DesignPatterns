package com.dreaming.design.problem;

/**
 * 看了上面的实现，很简单，而且还考虑了性能的问题，在内存中缓存了每个人相应的权限数据，
 * 使得每次判断权限的时候，速度大大加快，实现得挺不错，难道有什么问题吗?
 *
 * 仔细想想，问题就来了，既有缓存这种方式固有的问题，也有我们自己实现上的问题。
 * 先说说缓存固有的问题吧。这个不在本次讨论之列，大家了解一下就可以了。
 *
 * 缓存时间长度的问题，就是这些数据应该被缓存多久。如果是Web 应用，这种跟登录人员相关的权限数据,
 * 大多是放在session中进行缓存，当session超时的时候，就会被清除掉。如果不是Web应用呢?
 * 就得自己来控制了。另外就算是在Web应用中，也不一定非要缓存到session超时才清除。
 * 总之，控制缓存数据应该被缓存多长时间，是实现高效缓存的一个问题点。
 *
 * 缓存数据和真实数据的同步问题，这里的同步是指数据同步，不是多线程的同步。
 * 比如，上面的授权数据是存放在数据库里的，运行的时候缓存到内存中，
 * 如果真实的授权数据在运行期间发生了变化，那么缓存中的数据就应该和数据库中的数据同步，
 * 以保持一致，否则数据就错了。如何合理地同步数据，也是实现高效缓存的一个问题点。
 *
 * 缓存的多线程并发控制，对于缓存的数据，有些操作从缓存中取值，有些操作向缓存中添加值，
 * 有些操作在清除过期的缓存数据，有些操作在进行缓存和真实数据的同步。
 * 在一个多线程的环境下，如何合理地对缓存进行并发控制，也是实现高效缓存的一个问题点。
 *
 * 先简单提这么几个。事实上，实现合理、高效的缓存也不是一件很轻松的事情，
 * 好在这些问题都不在我们这次的讨论之列。这里的重心还是来讲述模式，而不是缓存实现。
 */
public class Main {
    public static void main(String[] args) {

    }
}
